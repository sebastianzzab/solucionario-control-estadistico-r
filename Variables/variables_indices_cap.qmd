---
title: "Diagramas de Control para Variables y An√°lisis de Indices de Capacidad de Procesos Aplicados con ${\\color{Blue} \\textbf{\\textsf{R}}}$"
---

# Diagramas de control para variables

Los diagramas de control para variables son herramientas gr√°ficas del Control Estad√≠stico de Procesos (CEP) que se usan para monitorear y analizar un proceso a lo largo del tiempo. Su objetivo principal es distinguir entre las variaciones comunes (aleatorias e inherentes al proceso) y las variaciones especiales o asignables (causadas por eventos espec√≠ficos e inesperados).

Estos diagramas se aplican a caracter√≠sticas de calidad que se pueden medir en una escala continua, como:

-   Peso de un producto.

-   Longitud o di√°metro de una pieza.

-   Temperatura de un horno.

-   Tiempo de un ciclo de producci√≥n.

## ¬øC√≥mo funcionan? 

üìà Un diagrama de control para variables grafica los datos de tu proceso en una secuencia de tiempo. T√≠picamente, consta de tres l√≠neas horizontales:

**L√≠nea Central (LC)**: Representa el promedio hist√≥rico o el valor objetivo de la caracter√≠stica que se est√° midiendo. Es el rendimiento esperado del proceso.

**L√≠mite de Control Superior (LCS)**: Se ubica tres desviaciones est√°ndar por encima de la l√≠nea central.

**L√≠mite de Control Inferior (LCI)**: Se ubica tres desviaciones est√°ndar por debajo de la l√≠nea central.

La idea es que, si un proceso es estable y solo presenta variaciones comunes, casi todos los puntos graficados se encontrar√°n dentro de estos l√≠mites de control y distribuidos de manera aleatoria alrededor de la l√≠nea central.

Un punto fuera de los l√≠mites de control o un patr√≥n no aleatorio (como una tendencia ascendente, 7 puntos seguidos de un mismo lado de la l√≠nea central, etc.) es una se√±al de que existe una causa especial de variaci√≥n. Esto indica que algo inusual ha ocurrido y que el proceso est√° "fuera de control", lo que requiere una investigaci√≥n para identificar y corregir el problema.

## Tipos m√°s comunes 

Generalmente, se usan en pares para monitorear tanto la tendencia central como la dispersi√≥n (variabilidad) del proceso:

**Gr√°fica** $\bar{X}‚àíR$ **(Medias y Rangos)**: Es la m√°s com√∫n. La gr√°fica $\bar{X}$ (de medias) monitorea el promedio del proceso, mientras que la gr√°fica $R$ (de rangos) monitorea la variabilidad dentro de las muestras. Se usa t√≠picamente con tama√±os de muestra peque√±os (entre 2 y 10).

**Gr√°fica** $\bar{X}‚àíS$ **(Medias y Desviaci√≥n Est√°ndar)**: Similar a la anterior, pero la gr√°fica $S$ usa la desviaci√≥n est√°ndar en lugar del rango para medir la variabilidad. Es estad√≠sticamente m√°s robusta y se prefiere cuando los tama√±os de muestra son m√°s grandes (mayores a 10).

**Gr√°fica** $I-MR$ **(Individuales y Rango M√≥vil)**: Se utiliza cuando solo se tiene una medici√≥n por cada punto en el tiempo (tama√±o de muestra = 1), como en procesos lentos o donde la medici√≥n es costosa o destructiva.

En el siguiente bloque de c√≥digo se cargan todas las librer√≠as o paquetes necesarios para el desarrollo de este capitulo, si no se tiene instalado alguno de ellos se instalaran autom√°ticamente. 

```{r}
#| label: carga-paquetes-necesarios
#| include: false
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
library(pacman)
pacman::p_load(ggplot2,ggfortify, DT, reshape2, knitr,  tidyverse, ggQC, pammtools, latex2exp, data.table, reactable, htmlwidgets, htmltools, highcharter, tinytex, qcc, kableExtra)
```

Del mismo modo, se crea una base de datos bib para los paquetes de R que se est√°n utilizando en este capitulo, la cual se puede usar para crear una bibliograf√≠a al final del capitulo.

```{r}
#| include: false
#| label: creacion-bibliografias

# Crear automaticamente una base de datos bib para los paquetes de R 
knitr::write_bib(
  c(
    .packages(), "knitr", "tidyverse", "qcc", "ggQC", "plotly",
    "highcharter", "kableExtra", "data.table", "pacman",
    "renv", "pammtools", "htmlwidgets", "htmltools", "data.table",
    "RColorBrewer", "latex2exp", "tinytex", "reactable"
  ),
  "packages.bib"
)

```

Por otro lado, aqui se crean funciones propias para darle formato a las salidas imprimidas en pantalla. las cuales se pueden usar en cualquier parte del capitulo.

```{r}
#| label: funciones-creadas
#| include: false

# funcion para ajustar fill-opacity usando css
fillOpacity <- function(., alpha = 0.5) {
  css <- sprintf("<style> .js-fill { fill-opacity: %s}
!important; } </style>", alpha)
  prependContent(., HTML(css))
}

# funcion para dar formato a numero
formato <- function(x, digits = 4) {
  if (!is.numeric(x)) stop("¬°La entrada debe ser numerica!")
  format(
    round(x, digits = digits),
    mode = "double",
    big.mark = ".",
    decimal.mark = ","
  )
}

```

## Diagrama de control para la Media($\bar{X}$) y el Rango($R$)
Los diagramas de control para la media ($\bar{X}$) y el rango ($R$) son herramientas fundamentales en el Control Estad√≠stico de Procesos (CEP). Estos diagramas permiten monitorear la tendencia central y la variabilidad de un proceso a lo largo del tiempo, ayudando a identificar si el proceso est√° bajo control estad√≠stico o si existen causas asignables que afectan su desempe√±o. Los mismos seran ejemplificados a continuaci√≥n.

:::: {.callout-tip icon="false" appearance="simple"}
::: {#exm-dcxr .Example}
### Aplicaci√≥n del diagrama de control para la Media($\bar{X}$) y el Rango($R$) {#sec-ejemplo-diagrama-xr}

<br/>Se van a establecer gr√°ficas de control para $\bar{X}$ y $R$ en determinada dimensi√≥n, en mil√≠metros, de una parte. Se reunieron datos en tama√±os de subgrupo igual a 6, y se citan a continuaci√≥n en la @tbl-datos-peso-promedio-rango-parte. Determine la l√≠nea central y los l√≠mites de control tentativos. Suponga que hay causas asignables, y revise la l√≠nea central y los l√≠mites.Este ejemplo fue tomado de @besterfield1995control.

```{r}
#| label: tbl-datos-peso-promedio-rango-parte
#| tbl-cap:  "Mediciones del peso promedio y el rango en mil√≠metros de una parte"
#| tbl-colwidths: [20,50]
# Creando vectoress para X barra y R
X_bar <- c(20.35, 20.40, 20.36, 20.65, 20.20, 20.40, 20.43, 20.37, 20.48, 20.42, 20.39, 20.38, 20.40, 20.41, 20.45, 20.34, 20.36, 20.42, 20.50, 20.31, 20.39, 20.39, 20.40, 20.41, 20.40)
R <- c(0.34, 0.36, 0.32, 0.36, 0.36, 0.35, 0.31, 0.34, 0.30, 0.37, 0.29, 0.30, 0.33, 0.36, 0.34, 0.36, 0.37, 0.73, 0.38, 0.35, 0.38, 0.33, 0.32, 0.34, 0.30)


# Creando el dataframe
df <- data.frame(X_bar = X_bar, R = R)

datos <- df |>
  dplyr::mutate(
    muestra = 1:nrow(df)
  ) |>
  dplyr::rename(
    media = X_bar, 
    rango = R     
  ) |>
  dplyr::relocate(
    muestra,
    .before = media
  ) |>
  data.table::as.data.table()

formato <- function(x, digits = 4) {
  formatC(x, format = "f", digits = digits, big.mark = ".", decimal.mark = ",")
}

# Configuraciones Reactable 
options(
  reactable.language = reactableLang(
    searchPlaceholder = "buscar...",
    pageNext = "Siguiente",
    pagePrevious = "Anterior",
    noData = "No entries found",
    pageInfo = "{rowStart} de {rowEnd} de {rows} filas"
  )
)

# Reactable tabla para los nuevos datos
reactable::reactable(
  datos,
  list(
    muestra = colDef(header = "Muestra", align = "right"),
    media = colDef(
      header = "\\( \\bar{x}_i \\)", align = "right",
      format = colFormat(
        separators = TRUE, digits = 3, locales = "es-ES"
      )
    ),
    rango = colDef(
      header = "\\( R_i \\)", align = "right",
      format = colFormat(
        separators = TRUE, digits = 3, locales = "es-ES"
      )
    )
  ),
  defaultColDef = colDef(align = "center"),
  striped = TRUE,
  bordered = TRUE,
  highlight = TRUE
)
```

Una vez observados los datos, Se proceder√° ahora a calcular los limites para ambos diagramas de control, para lo cual se usara el paquete `SixSigma` que contiene las constantes necesarias para calcular los limites de control, recordando que es un estudio inicial por lo que no se tienen ni los par√°metros ni estimaciones de los mismos. 

Primeramente, para la construcci√≥n del diagrama $R$, se requiere determinar $D_{3}$ y $D_{4}$, lo cual se puede obtener de la respectiva tabla, teniendo en cuenta que $n=6$, o mediante el siguiente bloque de c√≥digo: 

```{r}
#| label: d3-d4

n <- 6 # Tama√±o de muestra
D_3 <- ifelse(
  1 - 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd2(n)) < 0, 0, 1 - 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd3(n))
)
D_4 <- 1 + 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd2(n))

paste0("D_3 = ", formato(D_3), "   D_4 = ", formato(D_4))
```
De manera que, el calculo de los l√≠mites de control vendr√≠a dado por la siguiente expresi√≥n: 

$$
\begin{align*}
LCI & = D_{3}\,\bar{R}  \\
LC & = \bar{R}\\
LCS & = D_{4}\,\bar{R} 
\end{align*}
$$ {#eq-lcxr}

A continuaci√≥n se muestran los calculos en siguiente bloque de c√≥digo para el diagrama $R$:

```{r}
#| label: lci-Rbarra
n <- 6 # Tama√±o de muestra 

# Calculo D3 y D4 usando el paquete SixSigma 
D_3 <- ifelse(
  1 - 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd2(n)) < 0, 0, 1 - 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd2(n))
)
D_4 <- 1 + 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd2(n))

# Calculo el promedio de los rangos
R_barra <- mean(datos$rango)

# Calculo de los limites de control
lci_R <- R_barra * D_3
lc_R <- R_barra
lcs_R <- R_barra * D_4

# Imprimir los resultados
paste0("LCI_R = ", formato(lci_R), "    LC_R = ", formato(lc_R), "    LCS_R = ", formato(lcs_R))

```
Manualmente, el calculo es el siguiente:

$$
\begin{align*}
LCI & = D_{3}\,\bar{R} = `r D_3`*`r R_barra` = `r formato(lci_R)`  \\
LC & = \bar{R} = `r R_barra`  \\
LCS & = D_{4}\,\bar{R} = `r formato(D_4)`*`r R_barra`  = `r formato(lcs_R)`
\end{align*}
$$ 
La estimaci√≥n de la varianza viene dada por: 

$$
\hat{\sigma}=\frac{\bar{R}}{d_{2}}= \frac{`r R_barra`}{`r formato(SixSigma::ss.cc.getd2(n))`} = `r formato(R_barra/SixSigma::ss.cc.getd2(n))`
$$
Para el diagrama $\bar{x}$, los limites se obtienen mediante la siguiente formula:

$$
\begin{align*}
LCS & = \bar{\bar{x}} + A_2 \bar{R} \\
LC  & = \bar{\bar{x}} \\
LCI & = \bar{\bar{x}} - A_2 \bar{R}
\end{align*} 
$${#eq-lcx}

Igualmente se calculan ahora los limites para el diagrama $\bar{X}$, para lo cual se usara el paquete `SixSigma` que contiene las constantes necesarias para calcular los limites de control.

```{r}
#| label: lci-xbarra

n <- 6

# Calculo A_2 usando el paquete SixSigma 
A_2 <- 3 / (sqrt(n) * SixSigma::ss.cc.getd2(n))

# Calculo del promedio general de las medias muestrales
media_est <- mean(datos$media) 

# Calculo los limites de control
lci_X <- media_est - A_2 * R_barra
lc_X <- media_est
lcs_X <- media_est + A_2 * R_barra

# print de resultados
paste0("LCI_X = ", formato(lci_X), "    LC_X = ", formato(lc_X), "    LCS_X = ", formato(lcs_X))
```
Manualmente, los calculos se realizan de la siguiente forma: 

$$
\begin{align*}
LCS & = \bar{\bar{x}} + A_2 \bar{R} = `r formato(media_est)`+`r formato(A_2)`*`r R_barra`= `r formato(lcs_X)` \\
LC  & = \bar{\bar{x}} = `r formato(lc_X)`\\
LCI & = \bar{\bar{x}} - A_2 \bar{R} = `r formato(media_est)`-`r formato(A_2)`*`r R_barra`= `r formato(lci_X)`
\end{align*} 
$$

Una vez determinados los limites de control ya es posible realizar los diagramas de control respectivos con el paquete `highcharter`. Los cuales se pueden ver a continuaci√≥n:

```{r}
#| label: fig-R-highcharter
#| fig-cap: "Diagramas $R$ para el di√°metro interior (mm) de los anillos en la fase I con el paquete `highcharter`"

# Diagrama de Control para el Rango (Gr√°fico R)

highchart() |>
  hc_add_series(
    data = datos,
    hcaes(x = muestra, low = lc_R, high = lcs_R),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = datos,
    hcaes(x = muestra, low = lci_R, high = lc_R),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lcs_R), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lc_R), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lci_R), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", color = "black",
    hcaes(x = muestra, y = rango),
    marker = list(
      radius = 3, fillColor = "blue", symbol = "circle"
    ),
    useHTML = TRUE,
    name = "<b><i>R<sub>i</sub></i></b>",
    dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Muestra (n<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Rango (R<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |>
  hc_plotOptions(series = list(animation = FALSE) )
```

Se puede observar en la @fig-R-highcharter el rango asociado al subgrupo 18 se encuentra fuera de los limites de control, por lo que suponiendo causas asignables el proceso esta fuera de control estad√≠stico. Por lo que se tiene que recalcular los limites de control y construir nuevamente el diagrama $R$.

```{r}
#| label: fig-xbarra-highcharter
#| fig-cap: "Diagramas $\\bar{x}$ para el di√°metro interior (mm) de los anillos en la fase I con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = datos,
    hcaes(x = muestra, low = lc_X, high = lcs_X),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = datos,
    hcaes(x = muestra, low = lci_X, high = lc_X),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lcs_X), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lc_X), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lci_X), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", color = "black", hcaes(x = muestra, y = media),
    marker = list(radius = 3, fillColor = "blue"),
    useHTML = TRUE,
    name = "<b><i>Media</i></b>", dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Muestra (n<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Media</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |>
  hc_plotOptions(series = list(animation = FALSE) )
```

Se puede observar igualmente en la @fig-xbarra-highcharter que aqui existen dos puntos consecutivos (4 y 5) fuera de los limites de control , por lo que suponiendo causas atribuibles el proceso se encuentra fuera de control estadistico. Por lo que se tiene que recalcular los limites de control y contruir nuevamente el diagrama $\bar{X}$.

Los limites para el diagrama $R$, serian ahora los siguientes:

```{r}
#| label: lci-Rbarra-def
datos <- datos[-c(4,5,18)]
# Calculo D3 y D4 usando el paquete SixSigma 
D_3 <- ifelse(
  1 - 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd2(n)) < 0, 0, 1 - 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd2(n))
)
D_4 <- 1 + 3 * (SixSigma::ss.cc.getd3(n) / SixSigma::ss.cc.getd2(n))

# Calculo el promedio de los rangos 
R_barra <- mean(datos$rango)

# Calculo los limites de control
lci_R <- R_barra * D_3
lc_R <- R_barra
lcs_R <- R_barra * D_4

# print los resultados
paste0("LCI_R = ", formato(lci_R), "    LC_R = ", formato(lc_R), "    LCS_R = ", formato(lcs_R))

```

Por otro lado, los limites para el diagrama $\bar{X}$ son los siguientes:

```{r}
#| label: lci-xbarra-def
n <- 6

# Calculo A_2 usando el paquete SixSigma 
A_2 <- 3 / (sqrt(n) * SixSigma::ss.cc.getd2(n))

# Calculo del promedio global de the muestra means
media_est <- mean(datos$media) 

# Calculo los limites de control
lci_X <- media_est - A_2 * R_barra
lc_X <- media_est
lcs_X <- media_est + A_2 * R_barra

# print los resultados
paste0("LCI_X = ", formato(lci_X), "    LC_X = ", formato(lc_X), "    LCS_X = ", formato(lcs_X))
```

```{r}
#| label: fig-R-highcharter-def
#| fig-cap: "Diagramas $R$ para el di√°metro interior (mm) de los anillos en la fase I con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = datos,
    hcaes(x = muestra, low = lc_R, high = lcs_R),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = datos,
    hcaes(x = muestra, low = lci_R, high = lc_R),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lcs_R), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lc_R), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lci_R), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", color = "black",
    hcaes(x = muestra, y = rango),
    marker = list(
      radius = 3, fillColor = "blue", symbol = "circle"
    ),
    useHTML = TRUE,
    name = "<b><i>R<sub>i</sub></i></b>",
    dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Muestra (n<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Rango (R<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |>
  hc_plotOptions(series = list(animation = FALSE) )
```

Como se puede observar ninguno de los puntos se encuentra fuera de los limites de control.

```{r}
#| label: fig-xbarra-highcharter-def
#| fig-cap: "Diagramas $\\bar{x}$ para el di√°metro interior (mm) de los anillos en la fase I con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = datos,
    hcaes(x = muestra, low = lc_X, high = lcs_X),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = datos,
    hcaes(x = muestra, low = lci_X, high = lc_X),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lcs_X), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lc_X), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", hcaes(x = muestra, y = lci_X), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = datos,
    type = "line", color = "black", hcaes(x = muestra, y = media),
    marker = list(radius = 3, fillColor = "blue"),
    useHTML = TRUE,
    name = "<b><i>Media</i></b>", dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Muestra (n<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Media</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |>
  hc_plotOptions(series = list(animation = FALSE) )
```

Igualmente, como se puede observar ninguno de los puntos se encuentra fuera de los limites de control. Por lo que, dado que para ambos diagramas de control (@fig-R-highcharter-def y @fig-xbarra-highcharter-def) no se encuentran ahora puntos fuera de control, se puede decir entonces que el proceso es estable o bajo control tanto en media como en varianza.

### Capacidad del Proceso

Para determinar la capacidad del proceso estabilizado, se informa que la especificaci√≥n superior (LSE) para la dimensi√≥n de la parte es de 20.80 mm y la especificaci√≥n inferior (LIE) es de 20.00 mm. Con estos datos y las propiedades del proceso que has determinado (media del proceso revisada y desviaci√≥n est√°ndar estimada a partir del rango promedio revisado), calcula los √≠ndices de capacidad del proceso ($C_p$ y  $C_{pk}$) y eval√∫a qu√© tan bien est√° operando el proceso en relaci√≥n con las especificaciones.

Para empezar, una vez determinado que el proceso se encuentra bajo control estadistico , se procede a calcular los indices de capacidad del proceso, por este motivo se supondr√° que los datos siguen una distribuci√≥n normal. 

Los limites de tolerancia natural fueron los establecidos anteriormente, siendo estos $`r formato(lci_X)`$ y $`r formato(lcs_X)`$.


```{r}
#| label: fig-xr-cp
#| fig-cap: "Capacidad del proceso"
X_bar <- datos$media 
R <- datos$rango     

# Establecer los l√≠mites de especificaci√≥n
spec.limits <- c(20, 20.80)
n <- 6 # Tama√±o del subgrupo

# Calcular la media del rango revisada
R_barra <- mean(R)

# Estimar la desviaci√≥n est√°ndar del proceso (sigma) a partir de R_barra
# Usamos d2(n) para convertir el rango promedio en una estimaci√≥n de sigma
sd_estimado_proceso <- R_barra / SixSigma::ss.cc.getd2(n)

xbar_chart_obj <- qcc(X_bar, type = "xbar", sizes = n, plot = FALSE,
                      std.dev = sd_estimado_proceso)
capability <- process.capability(xbar_chart_obj, spec.limits = spec.limits , print = FALSE)

# Mostrar los √≠ndices de capacidad del proceso
#print(capability)
#summary(capability)
#plot(capability) # Para ver la gr√°fica de capacidad corregida

# Calcular la porci√≥n ca√≠da 
mean_data <- mean(X_bar) # Usar la media de las X_bar revisadas

lower_limit <- spec.limits[1]
upper_limit <- spec.limits[2]

# Proporci√≥n de unidades por debajo del l√≠mite inferior
portion_below <- pnorm(lower_limit, mean = mean_data, sd = sd_estimado_proceso)

# Proporci√≥n de unidades por encima del l√≠mite superior
portion_above <- 1 - pnorm(upper_limit, mean = mean_data, sd = sd_estimado_proceso)

# Porci√≥n ca√≠da total
portion_fallen <- portion_below + portion_above

portion_fallen <- sum(capability$exp)

# Mostrar la porci√≥n ca√≠da
cat("Porci√≥n ca√≠da:", formato(portion_fallen), "\n")
```
El an√°lisis de capacidad del proceso para la dimensi√≥n de la parte revela que, aunque hay un margen, el desempe√±o no es completamente √≥ptimo.

El **√≠ndice de capacidad potencial del proceso ($C_p$) de 0.999** indica una capacidad potencial **marginal**. Esto sugiere que la variabilidad intr√≠nseca del proceso es casi igual a la amplitud de las especificaciones. Seg√∫n Montgomery, valores de $C_p$ entre 0.67 y 1.0 son **no adecuados para el trabajo**, se√±alando que el proceso requiere un an√°lisis prdeundo y modificaciones para alcanzar una calidad satisfactoria, a pesar de estar muy cerca de 1.0.

El **√≠ndice de capacidad real del proceso ($C_{pk}$) de 0.992** es la **preocupaci√≥n principal**. Al ser el menor de los $C_{pL}$ y $C_{pU}$ (siendo $C_{pL}$ el que lo determina), revela que el proceso **no est√° perfectamente centrado** dentro de los l√≠mites de especificaci√≥n, mostrando una ligera tendencia hacia el l√≠mite inferior. Este valor por debajo de 1.0 confirma que el proceso **no es capaz** de cumplir consistentemente con los requisitos, ya que existe una probabilidad real de producir piezas fuera de especificaci√≥n.

El **√≠ndice de capacidad de Taguchi ($C_{pm}$) de 0.999**, siendo muy cercano al $C_p$, sugiere que, aunque hay una variabilidad inherente que "casi" cabe en las especificaciones, la **desviaci√≥n respecto al valor objetivo (Target)** es m√≠nima. Esto refuerza la necesidad de mejorar la uniformidad y precisi√≥n, principalmente enfoc√°ndose en reducir la variabilidad para aumentar la holgura del proceso dentro de las especificaciones.

La **porci√≥n ca√≠da esperada (suma de Exp<LSL 0.15% y Exp>USL 0.13%) es de 0.28%**. Esto significa que aproximadamente el **0.28%** de las partes producidas se espera que est√©n fuera de los l√≠mites de especificaci√≥n. Aunque el porcentaje observado (`Obs<LSL 0%`, `Obs>USL 0%`) fue cero en las 22 muestras, la expectativa de casi un 0.3% de defectos subraya la importancia de implementar medidas correctivas para reducir esta proporci√≥n y mejorar la precisi√≥n general del proceso de manufactura.
:::
::::

## Diagrama de control para la Media($\bar{X}$) y la Desviaci√≥n Est√°ndar($S$)
Para el caso de la media y la desviaci√≥n est√°ndar, se utilizan los diagramas de control $\bar{X}$ y $S$, respectivamente. Estos diagramas son √∫tiles para monitorear la estabilidad del proceso en t√©rminos de su media y variabilidad. A continuaci√≥n, se muestra un ejemplo de c√≥mo construir estos diagramas a traves de un ejemplo pr√°ctico.

:::: {.callout-tip icon="false" appearance="simple"}
::: {#exm-dcxs .Example}
### Aplicaci√≥n del diagrama de control para la Media($\bar{X}$) y la Desviaci√≥n Est√°ndar($S$) {#sec-ejemplo-diagrama-xs}

<br/>Se van a establecer gr√°ficas de control para la dureza Brinell de acero endurecido para herramientas, en kilogramos por mil√≠metro cuadrado. A continuaci√≥n se muestran los datos para tama√±os de subgrupo igual a 8. Determine la l√≠nea central y los l√≠mites de control tentativos para las gr√°ficas $\bar{x}$ y $s$. Suponga que los puntos fuera de control tienen causas asignables, y calcule los l√≠mites y l√≠nea central revisados. Este ejemplo fue tomado de @besterfield1995control.

```{r}
#| label: tbl-datos-dureza_Brinell
#| tbl-cap:  "Mediciones para la dureza Brinell de acero endurecido para herramientas, en kilogramos por mil√≠metro cuadrado"
# Crear el dataframe en R
numero_de_subgrupo <- 1:25
X_bar <- c(540, 534, 545, 561, 576, 523, 571, 547, 584, 552, 541, 545, 546, 551, 522, 579, 549, 508, 569, 574, 563, 561, 548, 556, 553)
S <- c(26, 23, 24, 27, 25, 50, 29, 29, 23, 24, 28, 25, 26, 24, 29, 26, 28, 23, 22, 28, 33, 23, 25, 27, 23)

df_dureza <- data.frame(NUMERO_DE_SUBGRUPO = numero_de_subgrupo, X_bar = X_bar, S = S)

dureza <- df_dureza |>
  dplyr::mutate(
    muestra = numero_de_subgrupo
  ) |>
  dplyr::rename(
    media = X_bar,        
    desviacion = S        
  ) |>
  dplyr::select(
    muestra,
    media,
    desviacion
  ) |>
  data.table::as.data.table()

options(
  reactable.language = reactableLang(
    searchPlaceholder = "Buscar...",
    pageNext = "Siguiente",
    pagePrevious = "Anterior",
    noData = "No se encontraron entradas",
    pageInfo = "{rowStart} de {rowEnd} de {rows} filas"
  )
)

reactable::reactable(
  dureza,
  columns = list(
    muestra = colDef(header = "Muestra", align = "right"),
    media = colDef(
      header = "\\( \\bar{x}_{i} \\)", align = "right",
      format = colFormat(
        separators = TRUE, digits = 3, locales = "es-ES" 
      )
    ),
    desviacion = colDef(
      header = "\\( S_{i} \\)", align = "right", 
      format = colFormat(
        separators = TRUE, digits = 2, locales = "es-ES" 
      )
    )
  ),
  striped = TRUE,
  bordered = TRUE,
  highlight = TRUE,
  filterable = TRUE,
  defaultColDef = colDef(align = "center")
)
```
Una vez observados los datos, Se proceder√° ahora a calcular los limites para ambos diagramas de control, para lo cual se usara igualmente el paquete `SixSigma` que contiene las constantes necesarias para calcular los limites de control, recordando que es un estudio inicial por lo que no se tienen ni los par√°metros ni estimaciones de los mismos. 

Se empezara calculando los limites del diagrama inicial $S$. Los cuales vienen dados por:
$$
\begin{align*}
LCS  & =  B_{4}\,\bar{S} \\
LC  & =  \bar{S}\\
LCI  & = B_{3}\,\bar{S}
\end{align*}
$$ {#eq-ls}

Por lo que son necesarios los valores de $B_{3}$ y $B_{4}$, pueden ubicarse en sus respectivas tablas, o ser calculados en R mediante el siguiente bloque de c√≥digo:

```{r}
#| label: B3-B4
# Define el Tama√±o de muestra 
n <- 8

# Calculo  de las constantes B_3 y B_4 para el diagrama de control S
B_3 <- ifelse(
  1 - 3 * sqrt(1 - SixSigma::ss.cc.getc4(n)^2) / SixSigma::ss.cc.getc4(n) < 0, 0,
  1 - 3 * sqrt(1 - SixSigma::ss.cc.getc4(n)^2) / SixSigma::ss.cc.getc4(n)
)
B_4 <- 1 + 3 * sqrt(1 - SixSigma::ss.cc.getc4(n)^2) / SixSigma::ss.cc.getc4(n)
paste("B_3=",B_3,"   B_4=",formato(B_4))
```

Los limites se calculan de la siguiente forma:

```{r}
#| label: lci-Sbarra
# Calculo del promedio global de las desviaciones estandar
S_barra <- mean(dureza$desviacion)

# Calculo de los limites de control para el diagrama S
lci_S <- B_3 * S_barra 
lc_S <- S_barra        
lcs_S <- B_4 * S_barra 

# print los calculos de los limites de control
paste0("LCI_S = ", formato(lci_S), "    LC_S = ", formato(lc_S), "    LCS_S = ", formato(lcs_S))
```

Manualmente, el calculo es el siguiente:

$$
\begin{align*}
LCS  & =  B_{4}\,\bar{S} = `r formato(B_4)`*`r formato(S_barra)`= `r formato(lcs_S)` \\
LC  & =  \bar{S}  = `r formato(lc_S)` \\
LCI  & = B_{3}\,\bar{S} = `r formato(B_3)`*`r formato(S_barra)`= `r formato(lci_S)`
\end{align*}
$$ 

Los limites para el diagrama de control $\bar{x}$ se calculan de la siguiente forma:
$$
\begin{align*}
LCI & = \bar{\bar{x}} - A_{3}\,\bar{S}  \\
LC & = \bar{\bar{x}}  \\
LCS & = \bar{\bar{x}} + A_{3}\,\bar{S} 
\end{align*}
$${#eq-lix}

Mediante el siguiente bloque de c√≥digo se obtienen los limites: 

```{r}
#| label: lci-xbarra2
media_est <- mean(dureza$media)
A_3 <- 3 / (sqrt(n) * SixSigma::ss.cc.getc4(n))
lci_X <- media_est - A_3 * S_barra
lc_X <-  media_est
lcs_X <- media_est + A_3 * S_barra
paste0("LCI = ", formato(lci_X), "    LC = ", formato(lc_X), "    LCS = ", formato(lcs_X))
```

Manualmente, se obtienen mediante el siguiente calculo:

$$
\begin{align*}
LCI & = \bar{\bar{x}} - A_{3}\,\bar{S} = `r formato(media_est)`-`r formato(A_3)`*`r formato(S_barra)`= `r formato(lci_X)`\\
LC & = \bar{\bar{x}} = `r formato(lc_X)` \\
LCS & = \bar{\bar{x}} + A_{3}\,\bar{S} = `r formato(media_est)`+`r formato(A_3)`*`r formato(S_barra)`= `r formato(lcs_X)`
\end{align*}
$$
Una vez ya calculados los limites. A continuaci√≥n se muestran cada uno de estos diagramas:

```{r}
#| label: fig-Sinicial-highcharter
#| fig-cap: "Diagrama $S$ para la dureza Brinell del acero (kg/mm¬≤) en la fase I con el paquete `highcharter`"
highchart() |>
  hc_add_series(
    data = dureza,
    hcaes(x = muestra, low = lc_S, high = lcs_S),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = dureza, 
    hcaes(x = muestra, low = lci_S, high = lc_S),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2,
    name = "", color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = dureza,
    type = "line", hcaes(x = muestra, y = lcs_S), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lc_S), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lci_S), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, # Puntos de datos reales
    type = "line", color = "black",
    hcaes(x = muestra, y = desviacion),
    marker = list(radius = 3, fillColor = "blue"), # A√±adido fillColor para consistencia
    useHTML = TRUE, name = "<b><i>S<sub>i</sub></i></b>",
    dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Muestra (n<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Desviaci√≥n est√°ndar (S<sub>i</sub>)</i></b><br>")
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |>
  hc_plotOptions(series = list(animation = FALSE) )
```

Como se puede observar en la @fig-Sinicial-highcharter se observa que el punto 6 esta fuera de los limites de control, se concluye que el proceso no esta bajo control estadistico en varianza. Por lo que suponiendo causas asignables se eliminara del diagrama para recalcular los limites y observar nuevamente el comportamiento del proceso.

```{r}
#| label: fig-xbarra2-inicial-highcharter
#| fig-cap: "Diagrama $\\bar{x}$ para la dureza Brinell del acero (kg/mm¬≤) en la fase I con el paquete `highcharter`"
highchart() |>
  hc_add_series(
    data = dureza, 
    hcaes(x = muestra, low = lc_X, high = lcs_X),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = dureza, 
    hcaes(x = muestra, low = lci_X, high = lc_X),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lcs_X), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lc_X), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lci_X), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, # Puntos de datos reales
    type = "line", color = "black", hcaes(x = muestra, y = media),
    marker = list(radius = 3, fillColor = "blue"),
    useHTML = TRUE,
    name = "<b><i>Media</i></b>", dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Muestra (n<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Media</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |>
  hc_plotOptions(series = list(animation = FALSE) )
```

Se puede observar en la @fig-xbarra2-inicial-highcharter que se tienen dos puntos fuera de los limites de control, siendo los puntos 8 y 18. Ahora bien, el punto 15 se encuentra muy cercano teniendo una diferencia con este de 0,46, lo cual es menor a unidad. Basado en uno de los criterios de General Electric, el cual establece que un punto que se encuentre muy cercano a uno de los limites debera considerarse como una advertencia de que el proceso no esta funcionando como deberia. Por lo que el proceso no se encuentra bajo control estadistico en su media, suponiendo causas asignables se procedera a eliminar los tres puntos de proceso, recalcular los limites y graficar nuevamente el diagrama.

Los nuevos limites para el diagrama $S$, se calculan en el siguiente bloque de c√≥digo: 
```{r}
#| label: lci-s-def
dureza <- dureza[-c(6,8,15,18)]
# Calculo grafico de control constants B_3 y B_4 para el diagrama S
# These constants depend on the Tama√±o de muestra 'n' y SixSigma::ss.cc.getc4(n)
B_3 <- ifelse(
  1 - 3 * sqrt(1 - SixSigma::ss.cc.getc4(n)^2) / SixSigma::ss.cc.getc4(n) < 0, 0,
  1 - 3 * sqrt(1 - SixSigma::ss.cc.getc4(n)^2) / SixSigma::ss.cc.getc4(n)
)
B_4 <- 1 + 3 * sqrt(1 - SixSigma::ss.cc.getc4(n)^2) / SixSigma::ss.cc.getc4(n)

# Calculo del promedio global de the subgroup standard deviations (S-bar)
S_barra <- mean(dureza$desviacion)

# Calculo los limites de control para el diagrama S
lci_S <- B_3 * S_barra 
lc_S <- S_barra       
lcs_S <- B_4 * S_barra 

# Define the 'formato' function as it was used in  original snippet
# (Assuming it formats numbers with commas as decimal separators y two digits)
formato <- function(x, digits = 4) {
  formatC(x, format = "f", digits = digits, big.mark = ".", decimal.mark = ",")
}

# print the Calculod control limits
paste0("LCI_S = ", formato(lci_S), "    LC_S = ", formato(lc_S), "    LCS_S = ", formato(lcs_S))

```

Por otro lado, los nuevos limites para el diagrama $\bar{X}$, se calculan en el siguiente bloque de c√≥digo:

```{r}
#| label: lci-xbarra2-def
media_est <- mean(dureza$media)
A_3 <- 3 / (sqrt(n) * SixSigma::ss.cc.getc4(n))
lci_X <- media_est - A_3 * S_barra
lc_X <-  media_est
lcs_X <- media_est + A_3 * S_barra
paste0("LCI = ", formato(lci_X), "    LC = ", formato(lc_X), "    LCS = ", formato(lcs_X))
```

A continuaci√≥n se muestran los diagramas de control:

```{r}
#| label: fig-Sinicial-highcharter-def
#| fig-cap: "Diagrama $S$ para la dureza Brinell del acero (kg/mm¬≤) en la fase I con el paquete `highcharter`"
highchart() |>
  hc_add_series(
    data = dureza,
    hcaes(x = muestra, low = lc_S, high = lcs_S),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = dureza, 
    hcaes(x = muestra, low = lci_S, high = lc_S),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2,
    name = "", color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = dureza,
    type = "line", hcaes(x = muestra, y = lcs_S), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lc_S), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lci_S), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, # Puntos de datos reales
    type = "line", color = "black",
    hcaes(x = muestra, y = desviacion),
    marker = list(radius = 3, fillColor = "blue"), # A√±adido fillColor para consistencia
    useHTML = TRUE, name = "<b><i>S<sub>i</sub></i></b>",
    dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Muestra (n<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Desviaci√≥n est√°ndar (S<sub>i</sub>)</i></b><br>")
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |>
  hc_plotOptions(series = list(animation = FALSE) )
```

Como se puede observar en la @fig-Sinicial-highcharter-def ninguno de los puntos se encuentra fuera de los limites de control.

```{r}
#| label: fig-xbarra2-inicial-highcharter-def
#| fig-cap: "Diagrama $\\bar{x}$ para la dureza Brinell del acero (kg/mm¬≤) en la fase I con el paquete `highcharter`"
highchart() |>
  hc_add_series(
    data = dureza, 
    hcaes(x = muestra, low = lc_X, high = lcs_X),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = dureza, 
    hcaes(x = muestra, low = lci_X, high = lc_X),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "",
    color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lcs_X), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lc_X), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, 
    type = "line", hcaes(x = muestra, y = lci_X), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = dureza, # Puntos de datos reales
    type = "line", color = "black", hcaes(x = muestra, y = media),
    marker = list(radius = 3, fillColor = "blue"),
    useHTML = TRUE,
    name = "<b><i>Media</i></b>", dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Muestra (n<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Media</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |>
  hc_plotOptions(series = list(animation = FALSE) )
```

Igualmente, como se puede observar ninguno de los puntos se encuentra fuera de los limites de control. Por lo que, dado que para ambos diagramas de control (@fig-Sinicial-highcharter-def y @fig-xbarra2-inicial-highcharter-def) no se encuentran ahora puntos fuera de control, se puede decir entonces que la dureza Brinell de acero endurecido para herramientas, en kilogramos por mil√≠metro cuadrado es estable tanto en media como en varianza.

### Capacidad del Proceso
Para determinar la capacidad del proceso estabilizado, se informa que la especificaci√≥n superior (LSE) para la dureza Brinell es de 600 kg/mm¬≤ y la especificaci√≥n inferior (LIE) es de 500 kg/mm¬≤. Con estos datos y las propiedades del proceso que has determinado (media del proceso revisada y desviaci√≥n est√°ndar estimada a partir del rango promedio revisado), calcula los √≠ndices de capacidad del proceso ($C_p$ y  $C_{pk}$) y eval√∫a qu√© tan bien est√° operando el proceso en relaci√≥n con las especificaciones.

Para empezar, una vez determinado que el proceso se encuentra bajo control estadistico , se procede a calcular los indices de capacidad del proceso, por este motivo se supondr√° que los datos siguen una distribuci√≥n normal. 

Los limites de tolerancia natural fueron los establecidos anteriormente, siendo estos $`r formato(lci_X)`$ y $`r formato(lcs_X)`$.

```{r}
#| label: fig-xs-cp
#| fig-cap: "Capacidad del proceso"

X_bar <- dureza$media
S <- dureza$desviacion
# Establecer los l√≠mites de especificaci√≥n
spec.limits <- c(500, 600)

# Calcular la media del rango revisada
S_barra <- mean(S)

# ESTO ES CR√çTICO: Estimar la desviaci√≥n est√°ndar del proceso (sigma) a partir de R_barra
# Usamos d2(n) para convertir el rango promedio en una estimaci√≥n de sigma
sd_estimado_proceso <- S_barra / SixSigma::ss.cc.getd2(n)

xbar_chart_obj <- qcc(X_bar, type = "xbar", sizes = n, plot = FALSE,
                      std.dev = sd_estimado_proceso)
capability <- process.capability(xbar_chart_obj, spec.limits = spec.limits , print = FALSE)

# Calcular la porci√≥n ca√≠da (esto deber√≠a ser consistente con 'capability$exp' ahora)
# mean_data es la media del proceso
mean_data <- mean(X_bar) # Usar la media de las X_bar revisadas

lower_limit <- spec.limits[1]
upper_limit <- spec.limits[2]

# Proporci√≥n de unidades por debajo del l√≠mite inferior
portion_below <- pnorm(lower_limit, mean = mean_data, sd = sd_estimado_proceso)

# Proporci√≥n de unidades por encima del l√≠mite superior
portion_above <- 1 - pnorm(upper_limit, mean = mean_data, sd = sd_estimado_proceso)

# Porci√≥n ca√≠da total
portion_fallen <- portion_below + portion_above

portion_fallen <- sum(capability$exp)

# Mostrar la porci√≥n ca√≠da
cat("Porci√≥n ca√≠da:", formato(portion_fallen), "\n")
```

El an√°lisis de capacidad del proceso para la **dureza Brinell de acero endurecido para herramientas** revela que el desempe√±o es **altamente capaz y robusto**. 

El **√≠ndice de capacidad potencial del proceso ($C_p$) de 1.85** indica una **excelente capacidad potencial**. Esto sugiere que la variabilidad intr√≠nseca del proceso es significativamente menor que la amplitud de las especificaciones. Un $C_p$ mayor a 1.33 es generalmente considerado **altamente adecuado** para el trabajo, lo que significa que el proceso puede cumplir consistentemente con los l√≠mites de dureza Brinell establecidos.

El **√≠ndice de capacidad real del proceso ($C_{pk}$) de 1.59** confirma la **gran capacidad del proceso**. Este valor, determinado por el $C_{pU}$ (1.59 vs $C_{pL}$ 2.11), revela que el proceso est√° **bien centrado** dentro de los l√≠mites de especificaci√≥n, aunque con una ligera tendencia hacia el l√≠mite superior. Un $C_{pk}$ superior a 1.33 es una se√±al de un proceso **altamente capaz y robusto**, con un riesgo muy bajo de producir mediciones de dureza fuera de las especificaciones.

El **√≠ndice de capacidad de Taguchi ($C_{pm}$) de 1.46** corrobora la **solidez del proceso** al considerar no solo la variabilidad y la centraci√≥n, sino tambi√©n la desviaci√≥n respecto al valor objetivo (Target = 550 kg/mm¬≤). Este valor alto sugiere que la salida del proceso (media observada de 557.0476 kg/mm¬≤) est√° razonablemente cerca del objetivo, y la variabilidad es baja, lo que garantiza una alta calidad y consistencia.

La **porci√≥n ca√≠da esperada (Exp<LSL 0% y Exp>USL 0%) es de 0%** en ambos lados de las especificaciones. Esto significa que se espera que **ninguna de las mediciones de dureza Brinell** est√© fuera de los l√≠mites de especificaci√≥n. La **porci√≥n observada fue tambi√©n del 0%** (`Obs<LSL 0%`, `Obs>USL 0%`) en las 21 muestras, lo que refuerza la conclusi√≥n de que el proceso es **extremadamente capaz y estable**, produciendo constantemente resultados dentro de los requisitos de dureza.

:::
::::

## Diagrama de control para la Media($\bar{X}$) y la Desviaci√≥n Est√°ndar($S$) con tama√±o de muestra variable

:::: {.callout-tip icon="false" appearance="simple"}
::: {#exm-dxstmv .Example}
## Aplicaci√≥n de los Diagramas $\bar{x}$ y $S$ con tama√±o de muestra variable. {#sec-ejemplo-diagrama-xstmv}

<br/>Una empresa de producci√≥n de alimentos se encuentra interesada en supervisar la concentraci√≥n de un conservante en los productos que derece, para ello toman entre 10 y 15 muestras de 20 lotes de producci√≥n distintos, midiendo la concentraci√≥n del conservante en su respectiva unidad.

La @tbl-datos-ejemplo-dxstmv muestra las medias y las desviaciones que present√≥ cada lote inspeccionado, junto con su la cantidad de muestras que se tom√≥ en el lote correspondiente. Este ejemplo fue tomado de @rendon2013control.

```{r}
#| label: tbl-datos-ejemplo-dxstmv
#| tbl-cap: "N√∫mero total de defectos en cada unidad de inspecci√≥n"
#| tbl-align: left
#| tbl-colwidths: [20,40]

datos_xstmv <- tibble(
  obs=c(1:20),
medias=c(1.76, 1.55, 1.79, 1.73, 1.74, 1.68, 1.84, 1.88, 1.83, 1.89, 1.76, 1.76, 1.85, 1.51, 2.08, 1.85, 1.69, 1.90, 1.84, 1.62
  ),
des=c(0.486, 0.508, 0.396, 0.622, 0.484, 0.377, 0.532, 0.424, 0.527, 0.409, 0.443, 0.403, 0.578, 0.409, 0.424, 0.479, 0.438, 0.429, 0.484, 0.434
  ),
tamano=c(11L, 12L, 14L, 14L, 10L, 15L, 13L, 12L, 14L, 11L, 12L, 15L, 10L, 13L, 14L, 11L, 10L, 12L, 15L, 13L
  )
)

knitr::kable(
  datos_xstmv,
  booktabs = TRUE,
  format = "html",
  col.names = c(
    "Lote", "Media", "Desviaci√≥n", "Tama√±o"
  ),
  align = "cc",
  escape = FALSE,
) 
```

Para la construcci√≥n del diagrama de control, se utilizar√° el criterio del tama√±o de muestra promedio, calculado de la siguiente forma:

$$
\begin{equation}
\bar{n}= \frac{\sum_{i=1}^{m}n_i}{m}
\end{equation}
$$ {#eq-tmp}

En R, el calculo se realiza de la siguiente forma:

```{r}
#| label: npro
sumn <- sum(datos_xstmv$tamano)
m <- 20
npro <- round(sumn/m,0)
paste(npro)
```

Los limites de control para el diagrama $S$ se obtienen de la siguiente forma: 
$$
\begin{align*}
LCI & = B_{3}\left(\bar{n} \right)\,\bar{S} \\
LC & = \bar{S} \\
LCS & = B_{4}\left(\bar{n} \right)\,\bar{S} 
\end{align*}
$$ {#eq-lstmv}

Del mismo, se calculan con R utilizando el siguiente bloque de c√≥digo:

```{r}
#| label: lci-Sbarratmv

B_3 <- ifelse(
  1 - 3 * sqrt(1 - SixSigma::ss.cc.getc4(npro)^2) / SixSigma::ss.cc.getc4(npro) < 0, 0,
  1 - 3 * sqrt(1 - SixSigma::ss.cc.getc4(npro)^2) / SixSigma::ss.cc.getc4(npro)
)
B_4 <- 1 + 3 * sqrt(1 - SixSigma::ss.cc.getc4(npro)^2) / SixSigma::ss.cc.getc4(npro)

media_est <- mean(datos_xstmv$medias)
S_barra <- mean(datos_xstmv$des)
lci_S <- B_3 * S_barra
lc_S <- S_barra
lcs_S <- B_4 * S_barra
paste0("LCI = ", formato(lci_S), "    LC = ", formato(lc_S), "    LCS = ", formato(lcs_S))

```

Los limites de control para $\bar{x}$ vienen dados por la siguiente expresi√≥n:

$$
\begin{align*}
LCI & = \bar{\bar{x}} - A_{3}\left(\bar{n} \right)\,\bar{S}  \\
LC & = \bar{\bar{x}} \\
LCS & = \bar{\bar{x}} + A_{3}\left(\bar{n} \right)\,\bar{S}
\end{align*}
$$ {#eq-lcxtmv}

En R, el calculo se realiza mediante el siguiente bloque de c√≥digo:

```{r}
#| label: lci-xbarra3

A_3 <- 3 / (sqrt(npro) * SixSigma::ss.cc.getc4(npro))
lci <- media_est - A_3 * S_barra
lc <-  media_est
lcs <- media_est + A_3 * S_barra
paste0("LCI = ", formato(lci), "    LC = ", formato(lc), "    LCS = ", formato(lcs))
```

La representaci√≥n gr√°fica de este diagrama se observa en la @fig-dcxbarraStmv-qcc:

```{r}
#| label: fig-dcxbarraStmv-qcc
#| fig-cap: "Diagramas $\\bar{x}$ y $S$ para la cantidad de conservante por lote con el paquete `qcc`"
#| fig-subcap:
#|   - "Diagrama $S$ inicial"
#|   - "Diagrama $\\bar{x}$ inicial"
#| layout-ncol: 2

# Diagrama S en la fase 1
S1 <- qcc(
  datos_xstmv$des,sizes = npro,limits = c(lci_S, lcs_S),
  type = "S", plot = FALSE
)
plot(
  S1,
  add.stats = FALSE, label.limits = c("LCI", "LCS"),
  title = "", xlab = "Lote", ylab = "Desviaci√≥n est√°ndar",
  chart.all = TRUE
)

# Diagrama xbarra en la fase 1
xbarra_xs2 <- qcc(
  datos_xstmv$medias, sizes = npro,limits = c(lci, lcs),
  type = "xbar",
  plot = FALSE
)
plot(
  xbarra_xs2,
  add.stats = FALSE, label.limits = c("LCI", "LCS"),
  title = "", xlab = "Lote", ylab = "Medias",
  chart.all = TRUE
)

```

Se observa que tanto el diagrama de control de la **desviaci√≥n est√°ndar ($S$)** como el diagrama de control de la **media ($\bar{X}$)**, como se muestra en la Figura @fig-dcxbarraStmv-qcc, tienen **todos sus puntos dentro de los l√≠mites de control**.

Esto indica que la **variabilidad del proceso** est√° bajo control estad√≠stico, permitiendo utilizar la estimaci√≥n de $\sigma$ (la desviaci√≥n est√°ndar del proceso) para el monitoreo futuro. De manera similar, el **centro del proceso** tambi√©n est√° bajo control estad√≠stico, operando bajo causas fortuitas. Por lo tanto, la estimaci√≥n de $\mu$ (la media del proceso) puede emplearse para supervisar las futuras concentraciones de conservantes en los alimentos producidos.

En resumen, el proceso de concentraci√≥n de conservantes en los alimentos se encuentra en **estado de control estad√≠stico**, tanto en su variabilidad como en su promedio, lo que permite la utilizaci√≥n de las estimaciones actuales para su supervisi√≥n y mejora continua.

### Capacidad del Proceso

Para determinar la capacidad del proceso estabilizado, se informa que la especificaci√≥n superior (LSE) para la concentraci√≥n de conservante es de 2.0 y la especificaci√≥n inferior (LIE) es de 1.0. Con estos datos y las propiedades del proceso que has determinado (media del proceso revisada y desviaci√≥n est√°ndar estimada a partir del rango promedio revisado), calcula los √≠ndices de capacidad del proceso ($C_p$ y  $C_{pk}$) y eval√∫a qu√© tan bien est√° operando el proceso en relaci√≥n con las especificaciones.

Los l√≠mites de tolerancia natural fueron los establecidos anteriormente, siendo estos $`r formato(lci)`$ y $`r formato(lcs)`$. 

```{r}
#| label: fig-xstmv-cp
#| fig-cap: "Capacidad del proceso"

X_bar <- datos_xstmv$medias
S <- datos_xstmv$des
# Establecer los l√≠mites de especificaci√≥n
spec.limits <- c(1, 2)

# Calcular la media del rango revisada
S_barra <- mean(S)

# ESTO ES CR√çTICO: Estimar la desviaci√≥n est√°ndar del proceso (sigma) a partir de R_barra
# Usamos d2(n) para convertir el rango promedio en una estimaci√≥n de sigma
sd_estimado_proceso <- S_barra / SixSigma::ss.cc.getd2(npro)

xbar_chart_obj <- qcc(X_bar, type = "xbar", sizes = npro, plot = FALSE,
                      std.dev = sd_estimado_proceso)
capability <- process.capability(xbar_chart_obj, spec.limits = spec.limits , print = FALSE)

# Calcular la porci√≥n ca√≠da (esto deber√≠a ser consistente con 'capability$exp' ahora)
# mean_data es la media del proceso
mean_data <- mean(X_bar) # Usar la media de las X_bar revisadas

lower_limit <- spec.limits[1]
upper_limit <- spec.limits[2]

# Proporci√≥n de unidades por debajo del l√≠mite inferior
portion_below <- pnorm(lower_limit, mean = mean_data, sd = sd_estimado_proceso)

# Proporci√≥n de unidades por encima del l√≠mite superior
portion_above <- 1 - pnorm(upper_limit, mean = mean_data, sd = sd_estimado_proceso)

# Porci√≥n ca√≠da total
portion_fallen <- portion_below + portion_above

portion_fallen <- sum(capability$exp)

# Mostrar la porci√≥n ca√≠da
cat("Porci√≥n ca√≠da:", formato(portion_fallen), "\n")
```

El an√°lisis de capacidad del proceso para la **concentraci√≥n de conservantes** en los productos alimenticios revela un desempe√±o con **oportunidades significativas de mejora**. 

El **√≠ndice de capacidad potencial del proceso ($C_p$) de 1.2** indica una capacidad potencial **aceptable, pero no √≥ptima**. Esto sugiere que la variabilidad intr√≠nseca del proceso, si estuviera perfectamente centrado, apenas cabe dentro de la amplitud de las especificaciones. Aunque un $C_p$ de 1.2 est√° por encima del umbral de 1.0 (que Montgomery considera "no adecuado"), a√∫n **no alcanza los niveles deseables de 1.33 o 1.67** para procesos de clase mundial, lo que significa que la variabilidad es a√∫n considerable en relaci√≥n con la tolerancia.

El **√≠ndice de capacidad real del proceso ($C_{pk}$) de 0.533** es la **principal preocupaci√≥n** en este an√°lisis. Al ser significativamente menor que 1.0, y en este caso determinado por $C_{pU}$ (0.533 vs $C_{pL}$ 1.86), revela que el proceso est√° **mal centrado** y muestra una **fuerte tendencia hacia el L√≠mite Superior de Especificaci√≥n (USL)**. Este valor, muy por debajo de 1.0, confirma que el proceso **no es capaz** de cumplir consistentemente con los requisitos de concentraci√≥n, ya que una parte sustancial de la distribuci√≥n se extiende m√°s all√° del l√≠mite superior.

El **√≠ndice de capacidad de Taguchi ($C_{pm}$) de 0.537** corrobora la **deficiencia del proceso**. Este valor, cercano al $C_{pk}$, refleja que la desviaci√≥n del proceso no solo es notable en relaci√≥n con las especificaciones, sino que tambi√©n est√° **desalineado con el valor objetivo (Target = 1.5)**. La media del proceso (1.7775) se ha desplazado considerablemente del objetivo, lo que penaliza fuertemente este √≠ndice y refuerza la necesidad urgente de reajustar la centraci√≥n del proceso.

La **porci√≥n ca√≠da esperada (Exp>USL 5.5%) es de 5.5%** por encima del l√≠mite superior. Esto significa que aproximadamente el **5.5%** de los lotes de producci√≥n se espera que tengan una concentraci√≥n de conservante por encima del l√≠mite permitido. Aunque la **porci√≥n observada fue del 0%** por debajo del LSL y **5%** por encima del USL en las 20 muestras (`Obs<LSL 0%`, `Obs>USL 5%`), la alta expectativa de defectos subraya la importancia cr√≠tica de implementar medidas correctivas inmediatas para **reducir la concentraci√≥n promedio y su variabilidad**, asegurando as√≠ que los productos cumplan con las normativas de conservantes.
:::
::::

## Diagrama de Control Para Observaciones Individuales

:::: {.callout-tip icon="false" appearance="simple"}
::: {#exm-dcmr .Example}
### Aplicaci√≥n del diagrama de control $MR$ {#sec-ejemplo-diagrama-mr}

<br/>En el departamento de sistemas se lleva un registro del tiempo de respuesta a solicitudes de servicio de clientes internos. Los √∫ltimos datos en horas y en el orden de ocurrencia se muestran en la @tbl-datos-tiempo_respuesta_solicitudes. Obtenga los l√≠mites de control para una carta de control de individuales e interpr√©telos. Este ejemplo fue tomado de @gutierrez2009control.

```{r}
#| label: tbl-datos-tiempo_respuesta_solicitudes
#| tbl-cap:  "Registros del tiempo de respuesta a solicitudes de servicio de clientes internos"
response_times <- c(
  39, 35, 49, 92, 41, 57, 38, 37, 33, 33, 44, 34, 119, 37,
  34, 32, 34, 23, 96, 43, 36, 32, 35, 42, 42, 34, 86, 27,
  42, 117, 33, 39, 43, 37, 78, 42, 37, 37, 33, 96, 26, 37,
  29, 32, 38, 98, 39, 43, 126, 87, 46, 31, 109, 37, 40, 37,
  28, 52, 122, 40, 29, 33, 35, 71, 62
)

# Create a dataframe for individual observations
# For individual charts, each observation is a "subgroup" de size 1.
# We'll create an index for each observation.
individual_times <- data.table::data.table(
  check.names = FALSE,
  Observacion = 1:length(response_times),
  Tiempo_Respuesta_Horas = response_times
) |>
  dplyr::mutate(
    MR = c(NA, abs(diff(Tiempo_Respuesta_Horas)))
  ) |>
  data.table::data.table()

options(
  reactable.language = reactableLang(
    searchPlaceholder = "Buscar",
    pageNext = "Siguiente",
    pagePrevious = "Anterior",
    noData = "Ninguna fila encontrada",
    pageInfo = "{rowStart} de {rowEnd} de {rows} filas"
  )
)

reactable::reactable(
  individual_times,
  # defaultColDef = colDef(
  #   headerStyle = list(background = "#f7f7f8")
  # ),
  columns = list(
    Observacion = colDef(header = "N√∫mero de Observacion", align = "right"),
    Tiempo_Respuesta_Horas = colDef(
      header = "Tiempo de respuesta \\(\\left( x_{i} \\right) \\)", 
      align = "right",
      format = colFormat(
        separators = TRUE, digits = 2, locales = "es-ES"
      )
    ),
    MR = colDef(
      header = "Rango M√≥vil \\(\\left({MR}_{i}\\right)\\)", 
      align = "right",
      format = colFormat(
        separators = TRUE, digits = 2, locales = "es-ES"
      )
    )
  ),
  striped = TRUE,
  bordered = TRUE,
  highlight = TRUE,
  filterable = TRUE,
  minRows = 10
)
```

Para estimar los parametros del diagrama es necesario calcular la media de la variable de interes, en este caso el tiempo de respuesta, y la media de los rangos moviles, este calculo es bastante sencillo, teniendo entonces $\bar{x}$= `r formato(mean(individual_times$Tiempo_Respuesta_Horas))` y $\overline{MR}$= `r formato(mean(individual_times$MR,na.rm = TRUE))` 

Los limites para el diagrama $x$ inicial se calculan de la siguiente forma:

$$
\begin{align*}
LCS  & =  \bar{x} + 2,6596 \, \overline{MR} \\
LC  & =  \bar{x} \\
LCI  & = \bar{x} - 2,6596\, \overline{MR} 
\end{align*}
$$ {#eq-lsxmr}

Mediante R, se calculan utilizando el siguiente bloque de c√≥digo:

```{r}
#| label: lci-x

xbarra <- mean(individual_times$Tiempo_Respuesta_Horas)
MRbarra <- mean(individual_times$MR, na.rm = TRUE)
desviacion <- MRbarra / 1.128

lci <- xbarra - 2.6596 * MRbarra
lc <-  xbarra
lcs <- xbarra + 2.6596 * MRbarra
paste0("LCI = ", formato(lci), "    LC = ", formato(lc), "    LCS = ", formato(lcs))
```

Manualmente, estos limites se calculan de la siguiente forma:

$$
\begin{align*}
LCS  & =  \bar{x} + 2,6596 \, \overline{MR} = `r formato(xbarra)`+2,6596*`r formato(MRbarra)`= `r formato(lcs)` \\
LC  & =  \bar{x} = `r formato(lc)` \\ 
LCI  & = \bar{x} - 2,6596\, \overline{MR} = `r formato(xbarra)`-2,6596*`r formato(MRbarra)`= `r formato(lci)`
\end{align*}
$$
Los limites para el diagrama inicial $MR$ se obtienen de la siguiente forma:
$$
\begin{align*}
LCS  & = 3,2677 \, \overline{MR}\\
LC  & = \overline{MR} \\
LCI  & = 0
\end{align*}.
$$ {#eq-lsxmr1}

Utilizando R, se calculan utilizando el siguiente bloque de c√≥digo: 

```{r}
#| label: lci-MR

lci_MR <- 0
lc_MR <- MRbarra
lcs_MR <- 3.2677 * MRbarra
paste0(
  "LCI = ", formato(lci_MR), "    LC = ", formato(lc_MR), "    LCS = ", formato(lcs_MR)
)
```

Manualmente, se obtienen mediante el siguiente calculo:

$$
\begin{align*}
LCS  & = 3,2677 \, \overline{MR}= 3,2677*`r formato(MRbarra)`= `r formato(lcs_MR)`\\
LC  & = \overline{MR} = `r formato(lc_MR)` \\ 
LCI  & = 0
\end{align*}.
$$
La estimaci√≥n de la desviaci√≥n viene dada por la siguiente expresi√≥n:

$$
\begin{equation}
\hat{\sigma}=\frac{\overline{\textit{MR}}}{1,1284} = \frac{`r MRbarra`}{1,1284}=`r formato(desviacion)`
\end{equation}
$$

Una vez los limites de control, ya es posible graficar los diagramas de control. Los cuales se pueden observar a continuacion:

```{r}
#| label: fig-MRinicial-highcharter
#| fig-cap: "Diagrama $\\textit{MR}$ inicial para el tiempo de respuesta a solicitudes de servicio de clientes internos con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = individual_times, 
    hcaes(x = Observacion, low = lc_MR, high = lcs_MR),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, 
    name = "", color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times, 
    hcaes(x = Observacion, low = lci_MR, high = lc_MR),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, 
    name = "", color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times, 
    type = "line", hcaes(x = Observacion, y = lcs_MR), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times,
    type = "line", hcaes(x = Observacion, y = lc_MR), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times, 
    type = "line", hcaes(x = Observacion, y = lci_MR), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times,
    type = "line", color = "black",
    hcaes(x = Observacion, y = MR),
    marker = list(radius = 3),useHTML = TRUE, 
    name = "<b><i>MR<sub>i</sub></i></b>",
    dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>N√∫mero de Observacion</b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Rango m√≥vil (MR<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |> 
  hc_plotOptions(series = list(animation = FALSE) )
```

Como se puede observar en la @fig-MRinicial-highcharter, el diagrama de control $MR$ inicial muestra que **todos los puntos est√°n dentro de los l√≠mites de control**, lo que indica que el proceso est√° bajo control estad√≠stico. Esto significa que la variabilidad del proceso es consistente y no hay evidencia de causas especiales que afecten el rango m√≥vil entre observaciones consecutivas.

```{r}
#| label: fig-x-inicial-highcharter
#| fig-cap: "Diagrama $x$ incial para el tiempo de respuesta a solicitudes de servicio de clientes internos con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = individual_times, 
    hcaes(x = Observacion, low = lc, high = lcs),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "", color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times, 
    hcaes(x = Observacion, low = lci, high = lc),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "", color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times, 
    type = "line", hcaes(x = Observacion, y = lcs), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times,
    type = "line", hcaes(x = Observacion, y = lc), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times, 
    type = "line", hcaes(x = Observacion, y = lci), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times,
    type = "line", color = "black", 
    hcaes(x = Observacion, y = Tiempo_Respuesta_Horas),
    marker = list(radius = 3),  useHTML = TRUE, 
    name = "<b><i>x<sub>i</sub></i></b>", dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>N√∫mero de observacion</b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Tiempo de respuesta de solicitudes  (x<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |> 
  hc_plotOptions(series = list(animation = FALSE) )
```

El diagrama de control $x$ inicial, como se muestra en la @fig-x-inicial-highcharter, indica que el punto numero 49 esta fuera de los limites de control. Esto sugiere que el proceso de respuesta a solicitudes de servicio no est√° bajo control estad√≠stico, y la media del tiempo de respuesta no es consistente a lo largo del tiempo.

Se calculan nuevamente los limites para el diagrama $x$ y $MR$ eliminando el punto 49, que es el √∫nico punto fuera de los limites de control:

```{r}
#| label: lci-MR-pre-def
individual_times1 <- individual_times[-49]
xbarra <- mean(individual_times1$Tiempo_Respuesta_Horas)
MRbarra <- mean(individual_times1$MR, na.rm = TRUE)
desviacion <- MRbarra / 1.128

lci <- xbarra - 2.6596 * MRbarra
lc <-  xbarra
lcs <- xbarra + 2.6596 * MRbarra
paste0("LCI = ", formato(lci), "    LC = ", formato(lc), "    LCS = ", formato(lcs))
```

Los nuevos limites para el diagrama $x$ son:

```{r}
#| label: lci-x-pre-def
lci_MR <- 0
lc_MR <- MRbarra
lcs_MR <- 3.2677 * MRbarra
paste0(
  "LCI = ", formato(lci_MR), "    LC = ", formato(lc_MR), "    LCS = ", formato(lcs_MR)
)
```

```{r}
#| label: fig-MRinicial-highcharter-pre-def
#| fig-cap: "Diagrama $\\textit{MR}$ inicial para el tiempo de respuesta a solicitudes de servicio de clientes internos con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = individual_times1, 
    hcaes(x = Observacion, low = lc_MR, high = lcs_MR),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, 
    name = "", color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times1, 
    hcaes(x = Observacion, low = lci_MR, high = lc_MR),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, 
    name = "", color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times1, 
    type = "line", hcaes(x = Observacion, y = lcs_MR), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times1,
    type = "line", hcaes(x = Observacion, y = lc_MR), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times1, 
    type = "line", hcaes(x = Observacion, y = lci_MR), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times1,
    type = "line", color = "black",
    hcaes(x = Observacion, y = MR),
    marker = list(radius = 3),useHTML = TRUE, 
    name = "<b><i>MR<sub>i</sub></i></b>",
    dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>N√∫mero de Observacion</b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Rango m√≥vil (MR<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |> 
  hc_plotOptions(series = list(animation = FALSE) )
```


```{r}
#| label: fig-x-inicial-highcharter-pre-def
#| fig-cap: "Diagrama $x$ incial para el tiempo de respuesta a solicitudes de servicio de clientes internos con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = individual_times1, 
    hcaes(x = Observacion, low = lc, high = lcs),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "", color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times1, 
    hcaes(x = Observacion, low = lci, high = lc),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "", color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times1, 
    type = "line", hcaes(x = Observacion, y = lcs), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times1,
    type = "line", hcaes(x = Observacion, y = lc), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times1, 
    type = "line", hcaes(x = Observacion, y = lci), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times1,
    type = "line", color = "black", 
    hcaes(x = Observacion, y = Tiempo_Respuesta_Horas),
    marker = list(radius = 3),  useHTML = TRUE, 
    name = "<b><i>x<sub>i</sub></i></b>", dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>N√∫mero de observacion</b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Tiempo de respuesta de solicitudes  (x<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |> 
  hc_plotOptions(series = list(animation = FALSE) )
```

Al observar la @fig-x-inicial-highcharter-pre-def se tiene que el punto 59 esta fuera de control. A partir de este paso se requieren de una serie de iteraciones para poder obtener un diagrama de control $x$ y $MR$ que cumpla con los requisitos de control estad√≠stico. Se utilizo en la parte de analisis del statgraphics correspondiente para el analisis de este diagrama, que exluyera automaticamente segun hubieran puntos fuera de control. Este proceso iterativo determino que las mediciones excluidas son la 4,5,6,7,8,9,10,13,19,20, 27,28,30,31,32,35,40,41,46,49,50,53,58,59,64 y 65.

Se calculan nuevamente los limites para el diagrama $x$ y $MR$ eliminando los puntos fuera de control, que son los puntos 4,5,6,7,8,9,10,13,19,20,27,28,30,31,32,35,40,41,46,49,50,53,58,59,64 y 65:

```{r}
#| label: lci-MR-def
individual_times <- individual_times[-c(4,5,6,7,8,9,10,13,19,20,27,28,30,31,32,35,40,41,46,49,50,53,58,59,64,65)]

individual_times <- individual_times %>%
  dplyr::mutate(
    MR = c(NA, abs(diff(Tiempo_Respuesta_Horas)))
  )

# Se necesita reindexar las observaciones despu√©s de eliminar filas:
individual_times$Observacion_Nueva <- 1:nrow(individual_times)

xbarra <- mean(individual_times$Tiempo_Respuesta_Horas)
MRbarra <- mean(individual_times$MR, na.rm = TRUE)
desviacion <- MRbarra / 1.128

lci <- xbarra - 2.6596 * MRbarra
lc <-  xbarra
lcs <- xbarra + 2.6596 * MRbarra
paste0("LCI = ", formato(lci), "    LC = ", formato(lc), "    LCS = ", formato(lcs))
```

Los nuevos limites para el diagrama $x$ son:

```{r}
#| label: lci-x-def
lci_MR <- 0
lc_MR <- MRbarra
lcs_MR <- 3.2677 * MRbarra
paste0(
  "LCI = ", formato(lci_MR), "    LC = ", formato(lc_MR), "    LCS = ", formato(lcs_MR)
)
```

Se grafican los diagramas de control $x$ y $MR$ con los nuevos limites de control:

```{r}
#| label: fig-MRinicial-highcharter-def
#| fig-cap: "Diagrama $\\textit{MR}$ inicial para el tiempo de respuesta a solicitudes de servicio de clientes internos con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = individual_times, 
    hcaes(x = Observacion, low = lc_MR, high = lcs_MR),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, 
    name = "", color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times, 
    hcaes(x = Observacion, low = lci_MR, high = lc_MR),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, 
    name = "", color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times, 
    type = "line", hcaes(x = Observacion, y = lcs_MR), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times,
    type = "line", hcaes(x = Observacion, y = lc_MR), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times, 
    type = "line", hcaes(x = Observacion, y = lci_MR), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times,
    type = "line", color = "black",
    hcaes(x = Observacion, y = MR),
    marker = list(radius = 3),useHTML = TRUE, 
    name = "<b><i>MR<sub>i</sub></i></b>",
    dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>N√∫mero de Observacion</b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Rango m√≥vil (MR<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |> 
  hc_plotOptions(series = list(animation = FALSE) )
```



```{r}
#| label: fig-x-inicial-highcharter-def
#| fig-cap: "Diagrama $x$ incial para el tiempo de respuesta a solicitudes de servicio de clientes internos con el paquete `highcharter`"

highchart() |>
  hc_add_series(
    data = individual_times, 
    hcaes(x = Observacion, low = lc, high = lcs),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "", color = "green",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times, 
    hcaes(x = Observacion, low = lci, high = lc),
    step = "hv", marker = list(enabled = FALSE, visible = FALSE),
    type = "arearange", fillOpacity = 0.2, name = "", color = "blue",
    showInLegend = FALSE, tooltip = list(pointFormat = "{NULL}")
  ) |>
  hc_add_series(
    data = individual_times, 
    type = "line", hcaes(x = Observacion, y = lcs), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCS</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times,
    type = "line", hcaes(x = Observacion, y = lc), useHTML = TRUE,
    color = "blue", name = "<b><i>LC</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times, 
    type = "line", hcaes(x = Observacion, y = lci), useHTML = TRUE,
    color = "red", dashStyle = "Dash", name = "<b><i>LCI</b></i>",
    step = "hv", marker = list(enabled = FALSE),
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_add_series(
    data = individual_times,
    type = "line", color = "black", 
    hcaes(x = Observacion, y = Tiempo_Respuesta_Horas),
    marker = list(radius = 3),  useHTML = TRUE, 
    name = "<b><i>x<sub>i</sub></i></b>", dashStyle = "Dash",
    tooltip = list(valueDecimals = 2)
  ) |>
  hc_xAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>N√∫mero de observacion</b><br>"
    )
  ) |>
  hc_yAxis(
    title = list(
      useHTML = TRUE,
      text = "<b><i>Tiempo de respuesta de solicitudes  (x<sub>i</sub>)</i></b><br>"
    )
  ) |>
  hc_tooltip(crosshairs = TRUE, shared = TRUE) |> 
  hc_plotOptions(series = list(animation = FALSE) )
```

La interpretaci√≥n de los gr√°ficos de control de individuales y rango m√≥vil (I-MR) (@fig-MRinicial-highcharter-def y @fig-x-inicial-highcharter-def) para el tiempo de respuesta a solicitudes de servicio de clientes internos indica que el proceso se encuentra en estado de control estad√≠stico. Esto significa que la variabilidad del proceso y su centrado son estables y predecibles.

### Capacidad del Proceso

El departamento de sistemas, buscando no solo la estabilidad del tiempo de respuesta, sino tambi√©n su adecuaci√≥n a las expectativas del cliente interno, ha establecido nuevos requisitos de servicio. Para una satisfacci√≥n √≥ptima, se ha determinado que el tiempo de respuesta a las solicitudes no debe ser inferior a 25 horas ni exceder las 50 horas. Adem√°s, la meta ideal es un tiempo de respuesta de 35 horas.

Con base en estos nuevos valores, se requiere calcular los √≠ndices de capacidad del proceso ($C_p$,$C_{pk}$, $C_{pm}$) para evaluar qu√© tan bien el proceso actual satisface estas especificaciones.

```{r}
#| label: mr-cp
#| fig-cap: "Capacidad del proceso"

response_times <- response_times[-c(4,5,6,7,8,9,10,13,19,20,27,28,30,31,32,35,40,41,46,49,50,53,58,59,64,65)]

x <- qcc(
  data = response_times,
  type = "xbar.one", # Use "xbar" type with sizes = 1 for individual charts
  sizes = 1,     # CRITICAL: Each observation is a subgroup de size 1
  plot = FALSE
)

# Establecer los l√≠mites de especificaci√≥n
spec.limits <- c(25, 50)

# Realizar el an√°lisis de capacidad del proceso
capability <- process.capability(x, spec.limits = spec.limits, target = 35, print = FALSE)

# Mostrar los √≠ndices de capacidad del proceso
#print(capability)

# Calcular la porci√≥n ca√≠da
# Suponemos que los datos siguen una distribuci√≥n normal
mean_data <- capability$center  # Media del proceso estimada por qcc
sd_data <- capability$std.dev      # Desviaci√≥n est√°ndar del proceso estimada por qcc
lower_limit <- spec.limits[1]
upper_limit <- spec.limits[2]

# Proporci√≥n de unidades por debajo del l√≠mite inferior
portion_below <- pnorm(lower_limit, mean = mean_data, sd = sd_data)

# Proporci√≥n de unidades por encima del l√≠mite superior
portion_above <- 1 - pnorm(upper_limit, mean = mean_data, sd = sd_data)

# Porci√≥n ca√≠da total
portion_fallen <- portion_below + portion_above

portion_fallen <- sum(capability$exp)

cat("Porci√≥n ca√≠da:", formato(portion_fallen), "\n")

```

El an√°lisis de capacidad del proceso para el **tiempo de respuesta a solicitudes de servicio de clientes internos** revela un desempe√±o con **claras deficiencias y la necesidad de mejoras urgentes**.

El **√≠ndice de capacidad potencial del proceso ($C_p$) de 0.842** indica una capacidad potencial **inadecuada**. Este valor, siendo significativamente menor que 1.0, sugiere que incluso si el proceso estuviera perfectamente centrado, su variabilidad intr√≠nseca es **demasiado grande** para ajustarse completamente dentro de los l√≠mites de especificaci√≥n establecidos (25 a 50 horas). Con un $C_p$ inferior a 1.0, el proceso inherentemente generar√° productos fuera de las especificaciones, lo que se√±ala una necesidad cr√≠tica de **reducir la variabilidad** en el tiempo de respuesta.

El **√≠ndice de capacidad real del proceso ($C_{pk}$) de 0.781** es la **preocupaci√≥n principal** en este an√°lisis. Al ser el menor de $C_{pL}$ (0.781) y $C_{pU}$ (0.904), este valor revela que el proceso **no solo es inherentemente incapaz ($C_p < 1.0$) sino que, adem√°s, est√° descentrado**, mostrando una **ligera tendencia hacia el l√≠mite inferior de especificaci√≥n (LSL)** de 25 horas. Un $C_{pk}$ tan bajo confirma que el proceso **no es capaz** de cumplir consistentemente con los requisitos de tiempo de respuesta, con una probabilidad real de producir solicitudes fuera de especificaci√≥n por debajo del l√≠mite inferior.

El **√≠ndice de capacidad de Taguchi ($C_{pm}$) de 0.802** corrobora la **deficiencia general del proceso**. Este valor, tambi√©n por debajo de 1.0 y cercano al $C_{pk}$, refleja que la desviaci√≥n del proceso no solo es notable en relaci√≥n con las especificaciones, sino que tambi√©n est√° **alejado del valor objetivo (Target = 35 horas)**. La media del proceso (36.58974 horas) se ha desplazado ligeramente del objetivo, lo que penaliza este √≠ndice y refuerza la necesidad de ajustar el centrado del proceso y, sobre todo, **reducir su variabilidad** para acercarse al tiempo de respuesta ideal de 35 horas.

La **porci√≥n ca√≠da esperada (suma de Exp<LSL 0.96% y Exp>USL 0.33%) es de 1.29%**. Esto significa que se espera que aproximadamente el **1.29%** de las solicitudes de servicio tengan un tiempo de respuesta fuera de los l√≠mites de especificaci√≥n, siendo la mayor√≠a de estos defectos por **tiempos de respuesta demasiado bajos (0.96% por debajo del LSL)**. Aunque el porcentaje observado (`Obs<LSL 0%`, `Obs>USL 2.6%`) es bajo, la expectativa de m√°s del 1% de defectos subraya la importancia cr√≠tica de implementar medidas correctivas inmediatas para **reducir la variabilidad del proceso y mejorar su centrado** para asegurar que los tiempos de respuesta cumplan consistentemente con los requisitos establecidos.
:::
::::
